#ifndef HAWKEYE_REPL_H_
#define HAWKEYE_REPL_H_
//using namespace std;

#include <vector>
#include <array>

#include "repl_policies.h"


// Hawkeye by Jain et al. 2016
class HawkeyeReplPolicy : public ReplPolicy {
	protected:
		const uint32_t MAX_PREDICT_ENTRIES = 0b1111111111111;
		/* The hawkeye predictor hold 8k entries */
		array < uint32_t, MAX_PREDICT_ENTRIES > hawkPredictor;

		uint64_t* rripArray;
		uint32_t numLines; // number of cache lines
		bool predVal; // predval used by the hawkeye predictor
		bool currentAcess;
		vector< MemReq* > accessSequence;
		vector< uint32_t > occupancyVector;
		/* to be used by the OPTGen to keep track of access sequence */

		uint32_t cacheAssoc; // cache associativity

		/* for set-associative caches, OPTgen maintians one occupancyVector for
		each cache set such that the maximum capacity of any occupancyVector entry
		never exceeds the cache associativity.*/

		const uint32_t hashedPC = 1 << 12; //13 bits hashed PC
		/* may be want to chage value later? */

	public:
		explicit HawkeyeReplPolicy(uint32_t _numLines) :numLines(_numLines) {
			rripArray = gm_calloc<uint64_t>(numLines);

			/* initialize hawkPredictor array to 0b000 */
			hawkPredictor.fill(0b000);
		}

		~HawkeyeReplPolicy() {
			gm_free(rripArray);
		}

		void update(uint32_t id, const MemReq* req) {
			/* called on cache hit and on cache miss after rank() and replaced()
			are called */

			/* OPTgen should be called on each cache access */
			bool OPTGenHit = OPTGen(const MemReq* req);

			predVal = hawkeyePredictor(const MemReq* req, OPTGenHit);
			/* Hawkeye predictor generates a binary prediction to indicate whether
			the line is cache-friendly or cache-averse. */

			associateRRIP(id, predVal, currentAcess);
			/* It uses prediction generated by Hawkeye predictor. currentAcess is
			wether the current access to the cache line was a hit or a miss. For a
			hit, currentAcess is 1 and vice versa.*/

		}

		void replaced(uint32_t id) {
			/* called when there is a miss and a cache block replaced */

		}

		template <typename C> inline uint32_t rank(const MemReq* req, C cands) {
			/* function called by cache for best candidate to be replaced */

			uint32_t bestCand = -1;
			bestCand = findCand(C cands);
			/* best candidate for replacement found */
			return bestCand;
		}

		DECL_RANK_BINDINGS;

	private:
		inline uint64_t findCand(C cands) {
			/* THE REPLACEMENT POLICY */
			for (auto ci = cands.begin(); ci != cands.end(); ci.inc()) {
				if (rripArray[*ci] == 7) {
					/* found the best candidate */
					return *ci;
				}
			}
			/* if could not find the best candidate, find one with highest rrip
			value i.e oldest cache-friendly line */
			uint64_t max = rripArray[*cands.begin()];
			for (auto ci = cands.begin(); ci != cands.end(); ci.end()) {
				max = (rripArray[*ci] > max)? rripArray[*ci]:max;
			}

			/* detrain its load instruction if the evicted line is present in the
			sampler*/
			// TODO: implement the above line

			return max;
		}

		bool OPTGen(const MemReq* req) {
			bool roofHit = true;
			uint32_t found = -1;

			/* what OPTGen thinks of the recent cache access */
			bool OPTGenHit = false;

			/* set the most recent entry of the occupancyVector to zero */
			occupancyVector.push_back(0);

			/* lookup last access to this mem */
			for (uint32_t index = 0; index < accessSequence.size()-1; index ++) {
				if(accessSequence[index] == req) {
					last_access = index;
					found = 1;
					break;
				}
			}

			/* if found, check if every element corresponding to the usage interval is less
			than the cache capacity */
			if (found > 0) {
				for (uint32_t i = last_access; i < accessSequence.size()-1; i++) {
					if (occupancyVector[i] == cacheAssoc) {roofHit = true;}
				}
			}

			/* if all the elements corresponding to the usage interval are less
			than the cache capacity then OPT would have placed 'X' in the cache,
			so the elements in usage interval in occupancyVector are incremented */

			if (!roofHit) {
				for (uint32_t i = last_access; i < accessSequence.size()-1; i++) {
					occupancyVector[i]++;
				}
				OPTGenHit = true;
			}

		return OPTGenHit;

		}

		bool hawkeyePredictor(const MemReq* req, bool _OPTGenHit) {
			/* THE HAWKEYE PREDICTOR */
			// TODO: implementation ; /*value of opt gen at that PC*
			if (_OPTGenHit) {
				/* pc that LAST accessed X is trained positively*/
				hawkPredictor[/*pc LAST accessed*/]++;
			} else {
				/* train negatively */
				hawkPredictor[/*pc that LAST accessed*/]--;
			}

			/*
			Cache-friendly = 1
			Cache-averse = 0
			*/
			if (hawkPredictor[hashedPC] >> 2 == 1) {
				// indexed by the current load pc
				// Higher order bit for the 3 bit counter
				return true; //Cache-friendly
			} else {
				return false; //Cache-averse
			}
			// return predVal;
		}

		void associateRRIP(uint32_t _id, bool _predVal, bool _currentAccess) {
			/* associate all cache resident lines with 3 bit RRIP counters*/
			if (_currentAccess && _predVal) {
				/* cache hit and pred to be cache friendly */
				// set RRIP to  0
				rripArray[_id] = 0;
			} else if (_currentAccess && !_predVal) {
				/* cache hit and pred to be cache averse */
				// set RRIP value to 7
				rripArray[_id] = 7;
			} else if (!_currentAccess && _predVal) {
				/* cache miss and pred to be cache friendly */
				// set RRIP val to 0
				rripArray[_id] = 0;
				/* increment RRIP values of OTHER cache-friendly lines to track their
				relative age */
				ageAllCacheLines(_id);
			} else if (!_currentAccess && !_predVal) {
				/* cache miss and pred to be cache averse */
				// set RRIP to 7
				rripArray[_id] = 7;
			}
		}

		inline void ageAllCacheLines(uint32_t _id) {
			/* age all OTHER cache lines: if (RRIP < 6) RRIP ++ */
			for (uint32_t i = 0; i < numLines; i++) {
				if (_id!=i) {
					if (rripArray[i] < 6) {rripArray[i]++;}
				}
			}
		}

		//template <typename C> uint64_t {}
};

#endif // HAWKEYE_REPL_H_
