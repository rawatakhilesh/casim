#ifndef HAWKEYE_REPL_H_
#define HAWKEYE_REPL_H_

#include <vector>

#include "repl_policies.h"


// Hawkeye by Jain et al. 2016
class HawkeyeReplPolicy : public ReplPolicy {
	protected:
		// TODO: Define cacheCapacity
		uint64_t* rripArray;
		uint32_t numLines; // number of cache lines
		bool predVal; // predval used by the hawkeye predictor
		bool currentAcess;
		vector< MemReq* > accessSequence;
		vector< uint32_t > occupancyVector;
	        const uint32_t HashedPC = 13; //13 bits hashed PC
		/* to be used by the OPTGen to keep track of access sequence */

	public:
		explicit HawkeyeReplPolicy(uint32_t _numLines) :numLines(_numLines) {
			rripArray = gm_calloc<uint64_t>(numLines);
		}

		~HawkeyeReplPolicy() {
			gm_free(rripArray);
		}

		void update(uint32_t id, const MemReq* req) {
			/* called on cache hit and on cache miss after rank() and replaced()
			are called */

			/* OPTgen should be called on each cache access */
			OPTGen(const MemReq* req);

			predVal = hawkeyePredictor();
			/* Hawkeye predictor generates a binary prediction to indicate whether
			the line is cache-friendly or cache-averse. */

			associateRRIP(id, predVal, currentAcess);
			/* It uses prediction generated by Hawkeye predictor. currentAcess is
			wether the current access to the cache line was a hit or a miss. For a
			hit, currentAcess is 1 and vice versa.*/

		}

		void replaced(uint32_t id) {
			/* called when there is a miss and a cache block replaced */

		}

		template <typename C> inline uint32_t rank(const MemReq* req, C cands) {
			/* function called by cache for best candidate to be replaced */

			uint32_t bestCand = -1;
			bestCand = findCand(C cands);
			/* best candidate for replacement found */
			return bestCand;
		}

		DECL_RANK_BINDINGS;

	private:
		inline uint64_t findCand(C cands) {
			/* THE REPLACEMENT POLICY */
			for (auto ci = cands.begin(); ci != cands.end(); ci.inc()) {
				if (rripArray[*ci] == 7) {
					/* found the best candidate */
					return *ci;
				}
			}
			/* if could not find the best candidate, find one with highest rrip
			value i.e oldest cache-friendly line */
			uint64_t max = rripArray[*cands.begin()];
			for (auto ci = cands.begin(); ci != cands.end(); ci.end()) {
				max = (rripArray[*ci] > max)? rripArray[*ci]:max;
			}

			/* detrain its load instruction if the evicted line is present in the
			sampler*/
			// TODO: implement the above line

			return max;
		}

		bool OPTGen(const MemReq* req) {
			bool roofHit = true;
			uint32_t found = -1;

			/* what OPTGen thinks of the recent cache access */
			bool OPTGenHit = false;

			/* set the most recent entry of the occupancyVector to zero */
			occupancyVector.push_back(0);

			/* lookup last access to this mem */
			for (uint32_t index = 0; index < accessSequence.size()-1; index ++) {
				if(accessSequence[index] == req) {
					last_access = index;
					found = 1;
					break;
				}
			}

			/* if found, check if every element corresponding to the usage interval is less
			than the cache capacity */
			if (found > 0) {
				for (uint32_t i = last_access; i < accessSequence.size()-1; i++) {
					if (occupancyVector[i] == cacheCapacity) {roofHit = true;}
				}
			}

			/* if all the elements corresponding to the usage interval are less
			than the cache capacity then OPT would have placed 'X' in the cache,
			so the elements in usage interval in occupancyVector are incremented */

			if (!roofHit) {
				for (uint32_t i = last_access; i < accessSequence.size()-1; i++) {
					occupancyVector[i]++;
				}
				OPTGenHit = true;
			}

		return OPTGenHit;

		}

		bool hawkeyePredictor(const MemReq* req) {
			/* THE HAWKEYE PREDICTOR */
			// TODO: implementation ; /*value of opt gen at that PC*
			if(OPTGen(req)){
			    if(/*value of opt gen at that PC*/ < 7){
				 /*value of opt gen at that PC*/++;
			    } else {
				if(/*value of opt gen at that PC*/ > 0)  {
				    /*value of opt gen at that PC*/ --;
			    }
			}
			/*
				Cache-friendly = 1
				Cache-averse = 0
			*/
			if (/*value of opt gen at that PC*/ > 4) { //Higher order bit for the 3 bit counter
		            return true; //Cache-friendly
		          } else {
		            return false; //Cache-averse
		          }
			//return predVal;
		}

		void associateRRIP(uint32_t _id, bool _predVal, bool _currentAccess) {
			/* associate all cache resident lines with 3 bit RRIP counters*/
			if (_currentAccess && _predVal) {
				/* cache hit and pred to be cache friendly */
				// set RRIP to  0
				rripArray[_id] = 0;
			} else if (_currentAccess && !_predVal) {
				/* cache hit and pred to be cache averse */
				// set RRIP value to 7
				rripArray[_id] = 7;
			} else if (!_currentAccess && _predVal) {
				/* cache miss and pred to be cache friendly */
				// set RRIP val to 0
				rripArray[_id] = 0;
				/* increment RRIP values of OTHER cache-friendly lines to track their
				relative age */
				ageAllCacheLines(_id);
			} else if (!_currentAccess && !_predVal) {
				/* cache miss and pred to be cache averse */
				// set RRIP to 7
				rripArray[_id] = 7;
			}
		}

		inline void ageAllCacheLines(uint32_t _id) {
			/* age all OTHER cache lines: if (RRIP < 6) RRIP ++ */
			for (uint32_t i = 0; i < numLines; i++) {
				if (_id!=i) {
					if (rripArray[i] < 6) {rripArray[i]++;}
				}
			}
		}

		//template <typename C> uint64_t {}
};

#endif // HAWKEYE_REPL_H_
